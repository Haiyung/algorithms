# Phase Three

> 目标1：掌握高级的数据结构--布隆过滤器和LRU cache
> 
> 目标2：掌握个别特殊但同样重要的算法--位运算和排序算法

## 方法

1. 10分钟，读题目并思考，想到尽可能多的题解
2. 若没有思路，则直接看答案；若有思路，则尝试用 20 分钟作答
3. 背诵并默写答案
4. 写测试用例
5. 两周之内，该题要独立完成五次

## 基础

- 位运算
- 布隆过滤器 Bloom Filter
    - 对比哈希表(HashTable): 需要哈希函数得到index值并映射到该位置，如果有重复则采取“拉链存储”的方式把多个元素都存在相同的位置的链表处，且会把整个要存储的元素都放到哈希表中。
        - 优点：全量存储
        - 缺点：哈希表比较“重”，浪费空间
    - 布隆过滤器: 用于检索一个元素是否在一个集合中
        - 优点：节省空间，且查询时间远远超过一般算法
        - 缺点：模糊查询，有一定的误识别率，且删除困难
    - 布隆过滤器的原理：
        - 每个元素会通过二进制索引函数得到该元素对应的N个二进制位；
        - 所有元素插入完毕后，当测试一个元素是否存在于该布隆过滤器中时，就通过二进制索引函数得到二进制位，如果这些二进制位的值都是1，则该值可能存在于布隆过滤器中；如果这些二进制位有一个为空，那么该值一定不存在于布隆过滤器。
        - 因此，布隆过滤器只适合当作快速查询的缓存使用，如果元素不存在，能够快速返回。
- LRU缓存
- 排序算法：[十大经典排序算法](https://www.cnblogs.com/onepixel/p/7674659.html)
    - 初级排序算法，O(N^2)：选择排序 & 插入排序 & 冒泡排序
    - 高级排序算法，O(N*LogN)：快速排序 & 归并排序 & 堆排序
    - 特殊排序算法，O(n)：计数排序 & 桶排序 & 基数排序
- 字符串算法

## 题目

位运算：
- #191 位1的个数
- #231 2的幂
- #190 颠倒二进制位
- #52  N皇后 II
- #338 比特位计数

LRU缓存：
- #146 LRU缓存机制

排序算法：
- 择排序
- 插入排序
- 冒泡排序
- 快速排序
- 归并排序
- #1122 数组的相对排序
- #242  有效的字母异位词
- #56   合并区间
- #493  翻转对


字符串基础问题:
- #709 转换成小写字母
- #58  最后一个单词的长度
- #771 宝石与石头
- #387 字符串中的第一个唯一字符
- #8   字符串转换整数 (atoi)

字符串操作问题:
- #14  最长公共前缀
- #344 反转字符串
- #541 反转字符串 II
- #151 翻转字符串里的单词
- #557 反转字符串中的单词 III
- #917 仅仅反转字母

异位词问题:
- #49  字母异位词分组
- #438 找到字符串中所有字母异位词

回文串问题:
- #125 验证回文串
- #680 验证回文字符串 II
- #5   最长回文子串

最长子串、子序列问题:
- #1143 最长公共子序列
- #72   编辑距离

字符串 + DP 问题:
- #10  正则表达式匹配
- #44  通配符匹配
- #115 不同的子序列

字符串匹配算法:
- [Boyer-Moore 算法](https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html)
- [Sunday 算法](https://blog.csdn.net/u012505432/article/details/52210975)
- 字符串匹配暴力法
- Rabin-Karp
- KMP字符串匹配算法
    - https://www.youtube.com/watch?v=dgPabAsTFa8
    - http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html
