# Phase Two

> 目标1：掌握最为关键的二维数据结构-树
> 
> 目标2：☆掌握递归算法

## 方法

1. 10分钟，读题目并思考，想到尽可能多的题解
2. 若没有思路，则直接看答案；若有思路，则尝试用 20 分钟作答
3. 背诵并默写答案
4. 写测试用例
5. 两周之内，该题要独立完成五次

## 基础

- 什么是树，什么是图，树和图最关键的差别是什么
- 链表是特殊的树，树是特殊的图
    - 链表仅有一个子节点，树有多个子节点
    - 没有环的图就是树
- 二叉树的遍历
    - 前序遍历 => Pre-order: 根-左-右
    - 中序遍历 => In-order: 左-根-右
    - 后序遍历 => Post-order: 左-右-根
- 二叉搜索树
    - 本质：解决遍历无序二叉树O(N)的时间复杂度，将二叉树变得有序。
    - 名称：二叉搜索树 Binary Search Tree; 二叉排序树; 有序二叉树 Ordered Binary Tree; 排序二叉树 Sorted Binary Tree
    - 特点：
        1. 左子树上所有节点的值均小于它的根节点的值
        2. 右子树上所有节点的值均大于它的根节点的值
        3. 以此类推，所有节点均满足上述条件
    - 时间复杂度
        - 查询 = 插入 = 删除 = O(log(N))
        - 详情见：[Big-O Cheat Sheet](https://www.bigocheatsheet.com/)
- 堆 [Heap](https://en.wikipedia.org/wiki/Heap_(data_structure)) => 可以迅速找到一堆数中的最大或者最小值的数据结构
    - 根节点最大的堆叫做大顶堆或大根堆
    - 根节点最小的堆叫做小顶堆或小根堆
    - 常见的堆有二叉堆、斐波那契堆、严格斐波那契堆等
- 二叉堆 => 堆的一种常见且简单的实现(并不是最优的实现)
    - 时间复杂度
        - 查询: O(1)
        - 删除: O(logN) => Heapify Down
        - 插入: O(logN) or O(1) => Heapify Up

## 进阶

- 递归：找到最小重复单元，在函数体内调用自己 ≈ 循环
    - 分治 Divide & Conquer
    - 回溯 Backtracking
    - 深度优先
    - 广度优先
- 贪心算法
    - 贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是全局最好或最优的算法。
- 二分查找
    - 二分查找是在有序的元素列表中查找元素
    - 二分查找的前提：
        1. 目标函数存在单调性（单调递增或单调递减），确保有序
        2. 存在上下界（bounded）
        3. 能够通过索引访问（index accessible）
- 动态规划|动态递推 Dynamic Programming
    - 将一个复杂的问题用递归的方式分解成简单的子问题
        - 动态规划和递归、分治没有根本的区别
        - 共性：都需要找到重复子问题
        - 差异：动态规划存在最优子结构，中途可以淘汰次优解
    - 动态规划关键点
        - 最优子结构：推导出的第n步的值是前面几个值的最佳值（累加/最大值/最小值）
        - 储存中间状态：开一个数组储存中间状态
        - 递推公式（状态转移方程或又称DP方程）
- 字典树
    - 定义：字典树，即 Trie 树，又称前缀树或单词查找树，是一种多叉树形结构。典型应用是用于统计和排序大量的字符串，经常被搜索引擎系统用于文本词频统计。优点是最大限度减少无谓的字符串比较，查询效率比哈希表高。
    - 字典树的基本性质
        1. 节点本身不存完整单词
        2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串
        3. 每个节点的所有子节点路径代表的字符都不相同
    - 字典树的核心思想：空间换时间 -> 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。
- 并查集
- 平衡二叉树
    - https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree
    - AVL树
        1. 平衡二叉搜索树
        2. 每个节点存平衡因子(balance factor)：{-1，0，1}
        3. 四种旋转操作
        4. 不足：节点需要存储额外信息，且调整次数频繁，维护成本较高
    - 红黑树
        - 近似平衡的二叉搜索树，它能够确保任何一个节点的左右子树的高度差小于两倍，这让它旋转的频次降低，维护这棵二叉树的时间成本更少，性能比AVL树更好
        - 红黑树的定义：
            - 每个结点要么是红色，要么是黑色
            - 根结点是黑色
            - 每个空结点(nil节点或空节点)是黑色
            - ☆不能有相邻的红色结点
            - ☆任何一个结点到其每个叶子结点的所有路径都包含相同数目的黑色节点
    - 对比AVL树和红黑树：
        - AVL trees provide faster lookups than Red Black Trees because they are more strictly balanced.
        - Red Black Trees provide faster insertion and removal operations than AVL trees as fewer rotations are done due to relatively relaxed balancing.
        - AVL trees store balance factors or heights with each node, thus requires storage for an integer per node whereas Red Black Tree requires only 1 bit of information per node.
        - Red Black Trees are used in most of the language libraries like map, multimap, multisetin C++ whereas AVL trees are used in databases where faster retrievals are required.
    - 二三树
    - B-tree
    - Splay tree
    - Treap

## 题目

- #94  二叉树的中序遍历
- #144 二叉树的前序遍历
- #589 N叉树的前序遍历
- #590 N叉树的后序遍历
- 最小的k个数
- #347 前 K 个高频元素
- 丑数
- 堆排序
- #70  爬楼梯
- #22  括号生成
- #98  验证二叉搜索树
- #226 翻转二叉树
- #104 二叉树的最大深度
- #111 二叉树的最小深度
- #297 二叉树的序列化与反序列化
- #236 二叉树的最近公共祖先
- #105 从前序与中序遍历序列构造二叉树
- #77  组合
- #46  全排列
- #50  Pow(x, n)
- #78  子集
- #169 多数元素
- #17  电话号码的字母组合
- #51  N皇后
- #102 二叉树的层序遍历
- #433 最小基因变化
- #515 在每个树行中找最大值
- #127 单词接龙
- #200 岛屿数量
- #529 扫雷游戏
- #860 柠檬水找零
- #122 买卖股票的最佳时机
- #455 分发饼干
- #874 模拟行走机器人
- #55  跳跃游戏
- #45  跳跃游戏 II
- #69  x 的平方根
- #367 有效的完全平方数
- #33  搜索旋转排序数组
- #74  搜索二维矩阵
- #153 寻找旋转排序数组中的最小值

动态规划：
- #斐波那契数列
- #62   不同路径
- #63   不同路径 II
- #1143 最长公共子序列
- #70   爬楼梯
- #120  三角形最小路径和
- #53   最大子序和
- #152  乘积最大子数组
- #322  零钱兑换
- #198  打家劫舍
- #213  打家劫舍 II
- #121  买卖股票的最佳时机
- #122  买卖股票的最佳时机 II
- #123  买卖股票的最佳时机 III
- #188  买卖股票的最佳时机 IV
- #309  最佳买卖股票时机含冷冻期
- #714  买卖股票的最佳时机含手续费
- #279  完全平方数
- #72   编辑距离
- #55   跳跃游戏
- #45   跳跃游戏 II
- #518  零钱兑换 II

其他：
- #208 实现 Trie (前缀树)
- #79  单词搜索 I
- #212 单词搜索 II
- #547 朋友圈
- #200 岛屿数量
- #130 被围绕的区域
