# Phase Two

> 目的：掌握最为关键的二维数据结构-树

## 方法

1. 10分钟，读题目并思考，想到尽可能多的题解
2. 若没有思路，则直接看答案；若有思路，则尝试用 20 分钟作答
3. 背诵并默写答案
4. 写测试用例
5. 两周之内，该题要独立完成五次

## 基础

- 什么是树，什么是图，树和图最关键的差别是什么
- 链表是特殊的树，树是特殊的图
    - 链表仅有一个子节点，树有多个子节点
    - 没有环的图就是树
- 二叉树的遍历
    - 前序遍历 => Pre-order: 根-左-右
    - 中序遍历 => In-order: 左-根-右
    - 后序遍历 => Post-order: 左-右-根
- 二叉搜索树
    - 本质：解决遍历无序二叉树O(N)的时间复杂度，将二叉树变得有序。
    - 名称：二叉搜索树 Binary Search Tree; 二叉排序树; 有序二叉树 Ordered Binary Tree; 排序二叉树 Sorted Binary Tree
    - 特点：
        1. 左子树上所有节点的值均小于它的根节点的值
        2. 右子树上所有节点的值均大于它的根节点的值
        3. 以此类推，所有节点均满足上述条件
    - 时间复杂度
        - 查询 = 插入 = 删除 = O(log(N))
        - 详情见：[Big-O Cheat Sheet](https://www.bigocheatsheet.com/)
- 堆 [Heap](https://en.wikipedia.org/wiki/Heap_(data_structure)) => 可以迅速找到一堆数中的最大或者最小值的数据结构
    - 根节点最大的堆叫做大顶堆或大根堆
    - 根节点最小的堆叫做小顶堆或小根堆
    - 常见的堆有二叉堆、斐波那契堆、严格斐波那契堆等
- 二叉堆 => 堆的一种常见且简单的实现(并不是最优的实现)
    - 时间复杂度
        - 查询: O(1)
        - 删除: O(logN) => Heapify Down
        - 插入: O(logN) or O(1) => Heapify Up

## 进阶

- 递归：找到最小重复单元，在函数体内调用自己 ≈ 循环
    - 分治 Divide & Conquer
    - 回溯 Backtracking
    - 深度优先
    - 广度优先
- 贪心算法
    - 贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是全局最好或最优的算法。
- 二分查找
    - 二分查找是在有序的元素列表中查找元素
    - 二分查找的前提：
        1. 目标函数存在单调性（单调递增或单调递减），确保有序
        2. 存在上下界（bounded）
        3. 能够通过索引访问（index accessible）
- 动态规划
- 字典树和并查集
- 红黑树和AVL树

## 题目

- #94 二叉树的中序遍历
- #144 二叉树的前序遍历
- #589 N叉树的前序遍历
- #590 N叉树的后序遍历
- 最小的k个数
- #347 前 K 个高频元素
- 丑数
- 堆排序
- #70 爬楼梯
- #22 括号生成
- #98 验证二叉搜索树
- #226 翻转二叉树
- #104 二叉树的最大深度
- #111 二叉树的最小深度
- #297 二叉树的序列化与反序列化
- #236 二叉树的最近公共祖先
- #105 从前序与中序遍历序列构造二叉树
- #77 组合
- #46 全排列
- #50 Pow(x, n)
- #78 子集
- #169 多数元素
- #17 电话号码的字母组合
- #51 N皇后
- #102 二叉树的层序遍历
- #433 最小基因变化
- #515 在每个树行中找最大值
- #127 单词接龙
- #200 岛屿数量
- #529 扫雷游戏
- #860 柠檬水找零
- #122 买卖股票的最佳时机
- #455 分发饼干
- #874 模拟行走机器人
- #55 跳跃游戏
- #45 跳跃游戏 II
- #69 x 的平方根
- #367 有效的完全平方数
- #33 搜索旋转排序数组
- #74 搜索二维矩阵
- #153 寻找旋转排序数组中的最小值
