# Phase Two

> 目的：掌握最为关键的二维数据结构-树

## 方法

1. 10分钟，读题目并思考，想到尽可能多的题解
2. 若没有思路，则直接看答案；若有思路，则尝试用 20 分钟作答
3. 背诵并默写答案
4. 写测试用例
5. 两周之内，该题要独立完成五次

## 基础

- 什么是树，什么是图，树和图最关键的差别是什么
- 链表是特殊的树，树是特殊的图
    - 链表仅有一个子节点，树有多个子节点
    - 没有环的图就是树
- 二叉树的遍历
    - 前序遍历 => Pre-order: 根-左-右
    - 中序遍历 => In-order: 左-根-右
    - 后序遍历 => Post-order: 左-右-根
- 二叉搜索树
    - 本质：解决遍历无序二叉树O(N)的时间复杂度，将二叉树变得有序。
    - 名称：二叉搜索树 Binary Search Tree; 二叉排序树; 有序二叉树 Ordered Binary Tree; 排序二叉树 Sorted Binary Tree
    - 特点：
        1. 左子树上所有节点的值均小于它的根节点的值
        2. 右子树上所有节点的值均大于它的根节点的值
        3. 以此类推，所有节点均满足上述条件
    - 时间复杂度
        - 查询 = 插入 = 删除 = O(log(N))
        - 详情见：[Big-O Cheat Sheet](https://www.bigocheatsheet.com/)
- 堆 [Heap](https://en.wikipedia.org/wiki/Heap_(data_structure)) => 可以迅速找到一堆数中的最大或者最小值的数据结构
    - 根节点最大的堆叫做大顶堆或大根堆
    - 根节点最小的堆叫做小顶堆或小根堆
    - 常见的堆有二叉堆、斐波那契堆、严格斐波那契堆等
- 二叉堆 => 堆的一种常见且简单的实现(并不是最优的实现)
    - 时间复杂度
        - 查询: O(1)
        - 删除: O(logN) => Heapify Down
        - 插入: O(logN) or O(1) => Heapify Up

## 进阶

- 递归：找到最小重复单元，在函数体内调用自己 ≈ 循环
    - 分治 Divide & Conquer
    - 回溯 Backtracking
- 深度优先
- 广度优先
- 贪心算法
- 二分查找
- 动态规划
- 字典树和并查集
- 红黑树和AVL树

## 题目
